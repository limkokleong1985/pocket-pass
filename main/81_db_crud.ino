//81_db_crud.ino
// ==== DB Diagnostics ====
static bool db_precheck_path_and_write() {
  Serial.printf("[DBCHK] exists(%s)=%d\n", BASE_DIR, (int)g_sd.exists(BASE_DIR));
  if (!g_sd.exists(BASE_DIR)) {
    Serial.printf("[DBCHK] mkdir(%s)\n", BASE_DIR);
    if (!g_sd.mkdir(BASE_DIR)) {
      Serial.printf("[DBCHK] mkdir(%s) FAILED\n", BASE_DIR);
      return false;
    }
    Serial.printf("[DBCHK] mkdir(%s) OK\n", BASE_DIR);
  }

  {
    String touchPath = String(BASE_DIR) + "/.touch";
    File f = g_sd.open(touchPath.c_str(), FILE_WRITE);
    if (!f) {
      Serial.printf("[DBCHK] open(%s, FILE_WRITE) FAILED\n", touchPath.c_str());
      return false;
    }
    f.print("ok");
    f.close();
    Serial.printf("[DBCHK] touch write OK at %s\n", touchPath.c_str());
  }

  {
    File vf = g_sd.open(DB_PATH, FILE_WRITE);
    Serial.printf("[DBCHK] open(%s, FILE_WRITE): %s\n", DB_PATH, vf ? "OK" : "FAIL");
    if (vf) vf.close();
  }

  Serial.printf("[DBCHK] exists(%s)=%d\n", DB_PATH, (int)g_sd.exists(DB_PATH));
  return true;
}

static void db_log_sqlite_error(const char* ctx, int rc) {
  const char* estr = sqlite3_errstr(rc);
  const char* emsg = g_db ? sqlite3_errmsg(g_db) : nullptr;
  Serial.printf("[DB] %s -> rc=%d estr=%s errmsg=%s\n",
                ctx, rc, estr ? estr : "null", emsg ? emsg : "null");
}

// ==== SQLite helpers: CRUDs ====
static bool db_insert_category(const String& name, int32_t& out_id) {
  out_id = -1;
  if (!db_open()) return false;
  if (g_crypto.K_meta.size() != 32) return false;

  if (!db_begin()) return false;

  // Store blank plaintext to avoid leaking names on SD (still NOT NULL)
  const char* sql = "INSERT INTO categories(name) VALUES(?);";
  sqlite3_stmt* st = nullptr;
  if (sqlite3_prepare_v2(g_db, sql, -1, &st, nullptr) != SQLITE_OK) { db_rollback(); return false; }

  sqlite3_bind_text(st, 1, "", -1, SQLITE_TRANSIENT);
  int rc = sqlite3_step(st);
  sqlite3_finalize(st);
  if (rc != SQLITE_DONE) { db_rollback(); return false; }

  out_id = (int32_t)sqlite3_last_insert_rowid(g_db);

  if (!db_upsert_category_meta(out_id, name)) { db_rollback(); return false; }

  if (!db_commit()) { db_rollback(); return false; }
  return true;
}

static bool db_update_category_name(int32_t id, const String& name) {
  if (!db_open()) return false;
  if (g_crypto.K_meta.size() != 32) return false;

  if (!db_begin()) return false;

  // Keep plaintext blank
  {
    const char* sql = "UPDATE categories SET name='' WHERE id=?;";
    sqlite3_stmt* st = nullptr;
    if (sqlite3_prepare_v2(g_db, sql, -1, &st, nullptr) != SQLITE_OK) { db_rollback(); return false; }
    sqlite3_bind_int(st, 1, id);
    int rc = sqlite3_step(st);
    sqlite3_finalize(st);
    if (rc != SQLITE_DONE) { db_rollback(); return false; }
  }

  if (!db_upsert_category_meta(id, name)) { db_rollback(); return false; }

  if (!db_commit()) { db_rollback(); return false; }
  return true;
}

static bool db_delete_category_if_empty(int32_t id, bool& deleted) {
  deleted = false;
  if (!db_open()) return false;
  const char* sqlc = "SELECT COUNT(*) FROM items WHERE category_id=?;";
  sqlite3_stmt* stc = nullptr;
  if (sqlite3_prepare_v2(g_db, sqlc, -1, &stc, nullptr) != SQLITE_OK) return false;
  sqlite3_bind_int(stc, 1, id);
  int cnt = 0;
  if (sqlite3_step(stc) == SQLITE_ROW) cnt = sqlite3_column_int(stc, 0);
  sqlite3_finalize(stc);
  if (cnt != 0) return true;

  const char* sqld = "DELETE FROM categories WHERE id=?;";
  sqlite3_stmt* std = nullptr;
  if (sqlite3_prepare_v2(g_db, sqld, -1, &std, nullptr) != SQLITE_OK) return false;
  sqlite3_bind_int(std, 1, id);
  int rc = sqlite3_step(std);
  sqlite3_finalize(std);
  deleted = (rc == SQLITE_DONE);
  return deleted;
}

static bool db_insert_item(int32_t category_id, const PasswordItem& it) {
  if (!db_open()) return false;
  if (g_crypto.K_meta.size() != 32) return false;

  if (!db_begin()) return false;

  // Store blank plaintext label to avoid leaking names
  const char* sql =
    "INSERT INTO items(id, category_id, label_plain, pw_ct_b64, pw_nonce_b64) "
    "VALUES(?, ?, ?, ?, ?);";
  sqlite3_stmt* st = nullptr;
  if (sqlite3_prepare_v2(g_db, sql, -1, &st, nullptr) != SQLITE_OK) { db_rollback(); return false; }

  sqlite3_bind_text(st, 1, it.id.c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_int(st, 2, category_id);
  sqlite3_bind_text(st, 3, "", -1, SQLITE_TRANSIENT);
  sqlite3_bind_text(st, 4, it.pw_ct_b64.c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_text(st, 5, it.pw_nonce_b64.c_str(), -1, SQLITE_TRANSIENT);

  int rc = sqlite3_step(st);
  sqlite3_finalize(st);
  if (rc != SQLITE_DONE) { db_rollback(); return false; }

  // Prefer label_ct_b64 generated by encrypt_label_password() (already correct AAD)
  bool okMeta = false;
  if (it.label_ct_b64.length() && it.label_nonce_b64.length()) {
    okMeta = db_upsert_item_meta_label(it.id, it.label_ct_b64, it.label_nonce_b64);
  } else {
    okMeta = db_upsert_item_meta_label_plain(it.id, it.label_plain);
  }
  if (!okMeta) { db_rollback(); return false; }

  if (!db_commit()) { db_rollback(); return false; }
  return true;
}

static bool db_update_item_label(const String& item_id, const String& new_label_plain) {
  if (!db_open()) return false;
  if (g_crypto.K_meta.size() != 32) return false;

  if (!db_begin()) return false;

  // Keep plaintext blank
  {
    const char* sql = "UPDATE items SET label_plain='' WHERE id=?;";
    sqlite3_stmt* st = nullptr;
    if (sqlite3_prepare_v2(g_db, sql, -1, &st, nullptr) != SQLITE_OK) { db_rollback(); return false; }
    sqlite3_bind_text(st, 1, item_id.c_str(), -1, SQLITE_TRANSIENT);
    int rc = sqlite3_step(st);
    sqlite3_finalize(st);
    if (rc != SQLITE_DONE) { db_rollback(); return false; }
  }

  if (!db_upsert_item_meta_label_plain(item_id, new_label_plain)) { db_rollback(); return false; }

  if (!db_commit()) { db_rollback(); return false; }
  return true;
}

static bool db_update_item_password(const String& item_id, const String& new_ct_b64, const String& new_nonce_b64, const PasswordVersion* oldVersionOrNull) {
  if (!db_open()) return false;
  if (!db_begin()) return false;
  {
    const char* sql = "UPDATE items SET pw_ct_b64=?, pw_nonce_b64=? WHERE id=?;";
    sqlite3_stmt* st = nullptr;
    if (sqlite3_prepare_v2(g_db, sql, -1, &st, nullptr) != SQLITE_OK) { db_rollback(); return false; }
    sqlite3_bind_text(st, 1, new_ct_b64.c_str(), -1, SQLITE_TRANSIENT);
    sqlite3_bind_text(st, 2, new_nonce_b64.c_str(), -1, SQLITE_TRANSIENT);
    sqlite3_bind_text(st, 3, item_id.c_str(), -1, SQLITE_TRANSIENT);
    int rc = sqlite3_step(st);
    sqlite3_finalize(st);
    if (rc != SQLITE_DONE) { db_rollback(); return false; }
  }
  if (oldVersionOrNull) {
    const char* sqlh = "INSERT INTO pw_history(item_id, pw_ct_b64, pw_nonce_b64, ts) VALUES(?, ?, ?, ?);";
    sqlite3_stmt* sth = nullptr;
    if (sqlite3_prepare_v2(g_db, sqlh, -1, &sth, nullptr) != SQLITE_OK) { db_rollback(); return false; }
    sqlite3_bind_text(sth, 1, item_id.c_str(), -1, SQLITE_TRANSIENT);
    sqlite3_bind_text(sth, 2, oldVersionOrNull->pw_ct_b64.c_str(), -1, SQLITE_TRANSIENT);
    sqlite3_bind_text(sth, 3, oldVersionOrNull->pw_nonce_b64.c_str(), -1, SQLITE_TRANSIENT);
    sqlite3_bind_int(sth, 4, (int)oldVersionOrNull->ts);
    int rc2 = sqlite3_step(sth);
    sqlite3_finalize(sth);
    if (rc2 != SQLITE_DONE) { db_rollback(); return false; }
  }
  if (!db_commit()) { db_rollback(); return false; }
  return true;
}

static bool db_delete_item(const String& item_id) {
  if (!db_open()) return false;
  if (!db_begin()) return false;
  const char* sqlh = "DELETE FROM pw_history WHERE item_id=?;";
  sqlite3_stmt* sth = nullptr;
  if (sqlite3_prepare_v2(g_db, sqlh, -1, &sth, nullptr) != SQLITE_OK) { db_rollback(); return false; }
  sqlite3_bind_text(sth, 1, item_id.c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_step(sth);
  sqlite3_finalize(sth);

  const char* sqli = "DELETE FROM items WHERE id=?;";
  sqlite3_stmt* sti = nullptr;
  if (sqlite3_prepare_v2(g_db, sqli, -1, &sti, nullptr) != SQLITE_OK) { db_rollback(); return false; }
  sqlite3_bind_text(sti, 1, item_id.c_str(), -1, SQLITE_TRANSIENT);
  int rc = sqlite3_step(sti);
  sqlite3_finalize(sti);
  if (rc != SQLITE_DONE) { db_rollback(); return false; }

  if (!db_commit()) { db_rollback(); return false; }
  return true;
}

static bool db_move_item(const String& item_id, int32_t new_category_id) {
  if (!db_open()) return false;
  const char* sql = "UPDATE items SET category_id=? WHERE id=?;";
  sqlite3_stmt* st = nullptr;
  if (sqlite3_prepare_v2(g_db, sql, -1, &st, nullptr) != SQLITE_OK) return false;
  sqlite3_bind_int(st, 1, new_category_id);
  sqlite3_bind_text(st, 2, item_id.c_str(), -1, SQLITE_TRANSIENT);
  int rc = sqlite3_step(st);
  sqlite3_finalize(st);
  return rc == SQLITE_DONE;
}

static bool db_column_exists(const char* table, const char* col) {
  String sql = "PRAGMA table_info(" + String(table) + ");";
  sqlite3_stmt* st = nullptr;
  if (sqlite3_prepare_v2(g_db, sql.c_str(), -1, &st, nullptr) != SQLITE_OK) return false;

  bool found = false;
  while (sqlite3_step(st) == SQLITE_ROW) {
    const char* name = (const char*)sqlite3_column_text(st, 1);
    if (name && String(name) == col) { found = true; break; }
  }
  sqlite3_finalize(st);
  return found;
}

static bool db_upsert_category_meta(int32_t category_id, const String& plain_name) {
  if (!db_open()) return false;
  if (g_crypto.K_meta.size() != 32) return false;

  std::vector<uint8_t> aad;
  make_category_field_aad(g_meta.db_uuid, category_id, "name", aad);

  String ct_b64, nonce_b64;
  if (!encrypt_string_meta_b64(aad, plain_name, ct_b64, nonce_b64)) return false;

  const char* sql =
    "INSERT OR REPLACE INTO category_meta(category_id, name_ct_b64, name_nonce_b64) "
    "VALUES(?, ?, ?);";
  sqlite3_stmt* st = nullptr;
  if (sqlite3_prepare_v2(g_db, sql, -1, &st, nullptr) != SQLITE_OK) return false;

  sqlite3_bind_int(st, 1, (int)category_id);
  sqlite3_bind_text(st, 2, ct_b64.c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_text(st, 3, nonce_b64.c_str(), -1, SQLITE_TRANSIENT);

  int rc = sqlite3_step(st);
  sqlite3_finalize(st);
  return rc == SQLITE_DONE;
}

static bool db_upsert_item_meta_label(const String& item_id,
                                     const String& label_ct_b64,
                                     const String& label_nonce_b64) {
  if (!db_open()) return false;

  const char* sql =
    "INSERT OR REPLACE INTO item_meta(item_id, label_ct_b64, label_nonce_b64) "
    "VALUES(?, ?, ?);";
  sqlite3_stmt* st = nullptr;
  if (sqlite3_prepare_v2(g_db, sql, -1, &st, nullptr) != SQLITE_OK) return false;

  sqlite3_bind_text(st, 1, item_id.c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_text(st, 2, label_ct_b64.c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_text(st, 3, label_nonce_b64.c_str(), -1, SQLITE_TRANSIENT);

  int rc = sqlite3_step(st);
  sqlite3_finalize(st);
  return rc == SQLITE_DONE;
}

static bool db_upsert_item_meta_label_plain(const String& item_id, const String& plain_label) {
  if (!db_open()) return false;
  if (g_crypto.K_meta.size() != 32) return false;

  std::vector<uint8_t> aad;
  make_item_label_aad(g_meta.db_uuid, item_id, aad);

  String ct_b64, nonce_b64;
  if (!encrypt_string_meta_b64(aad, plain_label, ct_b64, nonce_b64)) return false;

  return db_upsert_item_meta_label(item_id, ct_b64, nonce_b64);
}

static bool db_migrate_encrypt_names_labels_if_needed(bool wipe_plaintext) {
  if (!db_open()) return false;
  if (g_crypto.K_meta.size() != 32) {
    Serial.println("[MIG] K_meta missing (vault not unlocked?)");
    return false;
  }

  Serial.printf("[MIG] migrate encrypt names/labels wipe_plaintext=%d\n", (int)wipe_plaintext);

  if (!db_begin()) return false;

  // 1) Categories: if category_meta missing/empty, encrypt categories.name into category_meta
  {
    const char* sql =
      "SELECT c.id, c.name, "
      "COALESCE(cm.name_ct_b64,''), COALESCE(cm.name_nonce_b64,'') "
      "FROM categories c "
      "LEFT JOIN category_meta cm ON cm.category_id = c.id;";
    sqlite3_stmt* st = nullptr;
    if (sqlite3_prepare_v2(g_db, sql, -1, &st, nullptr) != SQLITE_OK) { db_rollback(); return false; }

    while (sqlite3_step(st) == SQLITE_ROW) {
      int32_t cid = (int32_t)sqlite3_column_int(st, 0);
      const char* name_plain_c = (const char*)sqlite3_column_text(st, 1);
      const char* ct_c         = (const char*)sqlite3_column_text(st, 2);
      const char* nonce_c      = (const char*)sqlite3_column_text(st, 3);

      String plain = name_plain_c ? String(name_plain_c) : String();
      String ct    = ct_c ? String(ct_c) : String();
      String nonce = nonce_c ? String(nonce_c) : String();

      if (ct.length() && nonce.length()) continue;     // already migrated
      if (!plain.length()) continue;                   // nothing to migrate

      if (!db_upsert_category_meta(cid, plain)) {
        sqlite3_finalize(st);
        db_rollback();
        return false;
      }
    }
    sqlite3_finalize(st);
  }

  // 2) Items: if item_meta missing/empty, encrypt items.label_plain into item_meta
  {
    const char* sql =
      "SELECT i.id, i.label_plain, "
      "COALESCE(im.label_ct_b64,''), COALESCE(im.label_nonce_b64,'') "
      "FROM items i "
      "LEFT JOIN item_meta im ON im.item_id = i.id;";
    sqlite3_stmt* st = nullptr;
    if (sqlite3_prepare_v2(g_db, sql, -1, &st, nullptr) != SQLITE_OK) { db_rollback(); return false; }

    while (sqlite3_step(st) == SQLITE_ROW) {
      const char* id_c         = (const char*)sqlite3_column_text(st, 0);
      const char* label_plain_c= (const char*)sqlite3_column_text(st, 1);
      const char* ct_c         = (const char*)sqlite3_column_text(st, 2);
      const char* nonce_c      = (const char*)sqlite3_column_text(st, 3);

      if (!id_c) continue;
      String item_id = String(id_c);

      String plain = label_plain_c ? String(label_plain_c) : String();
      String ct    = ct_c ? String(ct_c) : String();
      String nonce = nonce_c ? String(nonce_c) : String();

      if (ct.length() && nonce.length()) continue;     // already migrated
      if (!plain.length()) continue;

      if (!db_upsert_item_meta_label_plain(item_id, plain)) {
        sqlite3_finalize(st);
        db_rollback();
        return false;
      }
    }
    sqlite3_finalize(st);
  }

  // 3) Optional: wipe plaintext after successful meta migration
  if (wipe_plaintext) {
    if (!db_exec("UPDATE categories SET name='' WHERE name<>'';")) { db_rollback(); return false; }
    if (!db_exec("UPDATE items SET label_plain='' WHERE label_plain<>'';")) { db_rollback(); return false; }
  }

  if (!db_commit()) { db_rollback(); return false; }

  Serial.println("[MIG] migration OK");
  return true;
}