//81_db_crud.ino
// ==== DB Diagnostics ====
static bool db_precheck_path_and_write() {
  Serial.printf("[DBCHK] exists(%s)=%d\n", BASE_DIR, (int)g_sd.exists(BASE_DIR));
  if (!g_sd.exists(BASE_DIR)) {
    Serial.printf("[DBCHK] mkdir(%s)\n", BASE_DIR);
    if (!g_sd.mkdir(BASE_DIR)) {
      Serial.printf("[DBCHK] mkdir(%s) FAILED\n", BASE_DIR);
      return false;
    }
    Serial.printf("[DBCHK] mkdir(%s) OK\n", BASE_DIR);
  }

  {
    String touchPath = String(BASE_DIR) + "/.touch";
    File f = g_sd.open(touchPath.c_str(), FILE_WRITE);
    if (!f) {
      Serial.printf("[DBCHK] open(%s, FILE_WRITE) FAILED\n", touchPath.c_str());
      return false;
    }
    f.print("ok");
    f.close();
    Serial.printf("[DBCHK] touch write OK at %s\n", touchPath.c_str());
  }

  {
    File vf = g_sd.open(DB_PATH, FILE_WRITE);
    Serial.printf("[DBCHK] open(%s, FILE_WRITE): %s\n", DB_PATH, vf ? "OK" : "FAIL");
    if (vf) vf.close();
  }

  Serial.printf("[DBCHK] exists(%s)=%d\n", DB_PATH, (int)g_sd.exists(DB_PATH));
  return true;
}

static void db_log_sqlite_error(const char* ctx, int rc) {
  const char* estr = sqlite3_errstr(rc);
  const char* emsg = g_db ? sqlite3_errmsg(g_db) : nullptr;
  Serial.printf("[DB] %s -> rc=%d estr=%s errmsg=%s\n",
                ctx, rc, estr ? estr : "null", emsg ? emsg : "null");
}

// ==== SQLite helpers: CRUDs ====
static bool db_insert_category(const String& name, int32_t& out_id) {
  out_id = -1;
  if (!db_open()) return false;
  if (g_crypto.K_meta.size() != 32) return false;

  if (!db_begin()) return false;

  // Store blank plaintext to avoid leaking names on SD (still NOT NULL)
  const char* sql = "INSERT INTO categories(name) VALUES(?);";
  sqlite3_stmt* st = nullptr;
  if (sqlite3_prepare_v2(g_db, sql, -1, &st, nullptr) != SQLITE_OK) { db_rollback(); return false; }

  sqlite3_bind_text(st, 1, "", -1, SQLITE_TRANSIENT);
  int rc = sqlite3_step(st);
  sqlite3_finalize(st);
  if (rc != SQLITE_DONE) { db_rollback(); return false; }

  out_id = (int32_t)sqlite3_last_insert_rowid(g_db);

  if (!db_upsert_category_meta(out_id, name)) { db_rollback(); return false; }

  if (!db_commit()) { db_rollback(); return false; }
  return true;
}

static bool db_update_category_name(int32_t id, const String& name) {
  if (!db_open()) return false;
  if (g_crypto.K_meta.size() != 32) return false;

  if (!db_begin()) return false;

  // Keep plaintext blank
  {
    const char* sql = "UPDATE categories SET name='' WHERE id=?;";
    sqlite3_stmt* st = nullptr;
    if (sqlite3_prepare_v2(g_db, sql, -1, &st, nullptr) != SQLITE_OK) { db_rollback(); return false; }
    sqlite3_bind_int(st, 1, id);
    int rc = sqlite3_step(st);
    sqlite3_finalize(st);
    if (rc != SQLITE_DONE) { db_rollback(); return false; }
  }

  if (!db_upsert_category_meta(id, name)) { db_rollback(); return false; }

  if (!db_commit()) { db_rollback(); return false; }
  return true;
}

static bool db_delete_category_if_empty(int32_t id, bool& deleted) {
  deleted = false;
  if (!db_open()) return false;
  const char* sqlc = "SELECT COUNT(*) FROM items WHERE category_id=?;";
  sqlite3_stmt* stc = nullptr;
  if (sqlite3_prepare_v2(g_db, sqlc, -1, &stc, nullptr) != SQLITE_OK) return false;
  sqlite3_bind_int(stc, 1, id);
  int cnt = 0;
  if (sqlite3_step(stc) == SQLITE_ROW) cnt = sqlite3_column_int(stc, 0);
  sqlite3_finalize(stc);
  if (cnt != 0) return true;

  const char* sqld = "DELETE FROM categories WHERE id=?;";
  sqlite3_stmt* std = nullptr;
  if (sqlite3_prepare_v2(g_db, sqld, -1, &std, nullptr) != SQLITE_OK) return false;
  sqlite3_bind_int(std, 1, id);
  int rc = sqlite3_step(std);
  sqlite3_finalize(std);
  deleted = (rc == SQLITE_DONE);
  return deleted;
}

static bool db_insert_item(int32_t category_id, const PasswordItem& it) {
  if (!db_open()) return false;
  if (g_crypto.K_meta.size() != 32) return false;

  if (!db_begin()) return false;

  // Store blank plaintext label to avoid leaking names
  const char* sql =
    "INSERT INTO items(id, category_id, label_plain, pw_ct_b64, pw_nonce_b64) "
    "VALUES(?, ?, ?, ?, ?);";
  sqlite3_stmt* st = nullptr;
  if (sqlite3_prepare_v2(g_db, sql, -1, &st, nullptr) != SQLITE_OK) { db_rollback(); return false; }

  sqlite3_bind_text(st, 1, it.id.c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_int(st, 2, category_id);
  sqlite3_bind_text(st, 3, "", -1, SQLITE_TRANSIENT);
  sqlite3_bind_text(st, 4, it.pw_ct_b64.c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_text(st, 5, it.pw_nonce_b64.c_str(), -1, SQLITE_TRANSIENT);

  int rc = sqlite3_step(st);
  sqlite3_finalize(st);
  if (rc != SQLITE_DONE) { db_rollback(); return false; }

  // Prefer label_ct_b64 generated by encrypt_label_password() (already correct AAD)
  bool okMeta = false;
  if (it.label_ct_b64.length() && it.label_nonce_b64.length()) {
    okMeta = db_upsert_item_meta_label(it.id, it.label_ct_b64, it.label_nonce_b64);
  } else {
    okMeta = db_upsert_item_meta_label_plain(it.id, it.label_plain);
  }
  if (!okMeta) { db_rollback(); return false; }

  if (!db_commit()) { db_rollback(); return false; }
  return true;
}

static bool db_update_item_label(const String& item_id, const String& new_label_plain) {
  if (!db_open()) return false;
  if (g_crypto.K_meta.size() != 32) return false;

  if (!db_begin()) return false;

  // Keep plaintext blank
  {
    const char* sql = "UPDATE items SET label_plain='' WHERE id=?;";
    sqlite3_stmt* st = nullptr;
    if (sqlite3_prepare_v2(g_db, sql, -1, &st, nullptr) != SQLITE_OK) { db_rollback(); return false; }
    sqlite3_bind_text(st, 1, item_id.c_str(), -1, SQLITE_TRANSIENT);
    int rc = sqlite3_step(st);
    sqlite3_finalize(st);
    if (rc != SQLITE_DONE) { db_rollback(); return false; }
  }

  if (!db_upsert_item_meta_label_plain(item_id, new_label_plain)) { db_rollback(); return false; }

  if (!db_commit()) { db_rollback(); return false; }
  return true;
}

static bool db_update_item_password(const String& item_id, const String& new_ct_b64, const String& new_nonce_b64, const PasswordVersion* oldVersionOrNull) {
  if (!db_open()) return false;
  if (!db_begin()) return false;
  {
    const char* sql = "UPDATE items SET pw_ct_b64=?, pw_nonce_b64=? WHERE id=?;";
    sqlite3_stmt* st = nullptr;
    if (sqlite3_prepare_v2(g_db, sql, -1, &st, nullptr) != SQLITE_OK) { db_rollback(); return false; }
    sqlite3_bind_text(st, 1, new_ct_b64.c_str(), -1, SQLITE_TRANSIENT);
    sqlite3_bind_text(st, 2, new_nonce_b64.c_str(), -1, SQLITE_TRANSIENT);
    sqlite3_bind_text(st, 3, item_id.c_str(), -1, SQLITE_TRANSIENT);
    int rc = sqlite3_step(st);
    sqlite3_finalize(st);
    if (rc != SQLITE_DONE) { db_rollback(); return false; }
  }
  if (oldVersionOrNull) {
    const char* sqlh = "INSERT INTO pw_history(item_id, pw_ct_b64, pw_nonce_b64, ts) VALUES(?, ?, ?, ?);";
    sqlite3_stmt* sth = nullptr;
    if (sqlite3_prepare_v2(g_db, sqlh, -1, &sth, nullptr) != SQLITE_OK) { db_rollback(); return false; }
    sqlite3_bind_text(sth, 1, item_id.c_str(), -1, SQLITE_TRANSIENT);
    sqlite3_bind_text(sth, 2, oldVersionOrNull->pw_ct_b64.c_str(), -1, SQLITE_TRANSIENT);
    sqlite3_bind_text(sth, 3, oldVersionOrNull->pw_nonce_b64.c_str(), -1, SQLITE_TRANSIENT);
    sqlite3_bind_int(sth, 4, (int)oldVersionOrNull->ts);
    int rc2 = sqlite3_step(sth);
    sqlite3_finalize(sth);
    if (rc2 != SQLITE_DONE) { db_rollback(); return false; }
  }
  if (!db_commit()) { db_rollback(); return false; }
  return true;
}

static bool db_delete_item(const String& item_id) {
  if (!db_open()) return false;
  if (!db_begin()) return false;
  const char* sqlh = "DELETE FROM pw_history WHERE item_id=?;";
  sqlite3_stmt* sth = nullptr;
  if (sqlite3_prepare_v2(g_db, sqlh, -1, &sth, nullptr) != SQLITE_OK) { db_rollback(); return false; }
  sqlite3_bind_text(sth, 1, item_id.c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_step(sth);
  sqlite3_finalize(sth);

  const char* sqli = "DELETE FROM items WHERE id=?;";
  sqlite3_stmt* sti = nullptr;
  if (sqlite3_prepare_v2(g_db, sqli, -1, &sti, nullptr) != SQLITE_OK) { db_rollback(); return false; }
  sqlite3_bind_text(sti, 1, item_id.c_str(), -1, SQLITE_TRANSIENT);
  int rc = sqlite3_step(sti);
  sqlite3_finalize(sti);
  if (rc != SQLITE_DONE) { db_rollback(); return false; }

  if (!db_commit()) { db_rollback(); return false; }
  return true;
}

static bool db_move_item(const String& item_id, int32_t new_category_id) {
  if (!db_open()) return false;
  const char* sql = "UPDATE items SET category_id=? WHERE id=?;";
  sqlite3_stmt* st = nullptr;
  if (sqlite3_prepare_v2(g_db, sql, -1, &st, nullptr) != SQLITE_OK) return false;
  sqlite3_bind_int(st, 1, new_category_id);
  sqlite3_bind_text(st, 2, item_id.c_str(), -1, SQLITE_TRANSIENT);
  int rc = sqlite3_step(st);
  sqlite3_finalize(st);
  return rc == SQLITE_DONE;
}

static bool db_column_exists(const char* table, const char* col) {
  String sql = "PRAGMA table_info(" + String(table) + ");";
  sqlite3_stmt* st = nullptr;
  if (sqlite3_prepare_v2(g_db, sql.c_str(), -1, &st, nullptr) != SQLITE_OK) return false;

  bool found = false;
  while (sqlite3_step(st) == SQLITE_ROW) {
    const char* name = (const char*)sqlite3_column_text(st, 1);
    if (name && String(name) == col) { found = true; break; }
  }
  sqlite3_finalize(st);
  return found;
}

static bool db_upsert_category_meta(int32_t category_id, const String& plain_name) {
  if (!db_open()) return false;
  if (g_crypto.K_meta.size() != 32) return false;

  std::vector<uint8_t> aad;
  make_category_field_aad(g_meta.db_uuid, category_id, "name", aad);

  String ct_b64, nonce_b64;
  if (!encrypt_string_meta_b64(aad, plain_name, ct_b64, nonce_b64)) return false;

  const char* sql =
    "INSERT OR REPLACE INTO category_meta(category_id, name_ct_b64, name_nonce_b64) "
    "VALUES(?, ?, ?);";
  sqlite3_stmt* st = nullptr;
  if (sqlite3_prepare_v2(g_db, sql, -1, &st, nullptr) != SQLITE_OK) return false;

  sqlite3_bind_int(st, 1, (int)category_id);
  sqlite3_bind_text(st, 2, ct_b64.c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_text(st, 3, nonce_b64.c_str(), -1, SQLITE_TRANSIENT);

  int rc = sqlite3_step(st);
  sqlite3_finalize(st);
  return rc == SQLITE_DONE;
}

static bool db_upsert_item_meta_label(const String& item_id,
                                     const String& label_ct_b64,
                                     const String& label_nonce_b64) {
  if (!db_open()) return false;

  const char* sql =
    "INSERT OR REPLACE INTO item_meta(item_id, label_ct_b64, label_nonce_b64) "
    "VALUES(?, ?, ?);";
  sqlite3_stmt* st = nullptr;
  if (sqlite3_prepare_v2(g_db, sql, -1, &st, nullptr) != SQLITE_OK) return false;

  sqlite3_bind_text(st, 1, item_id.c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_text(st, 2, label_ct_b64.c_str(), -1, SQLITE_TRANSIENT);
  sqlite3_bind_text(st, 3, label_nonce_b64.c_str(), -1, SQLITE_TRANSIENT);

  int rc = sqlite3_step(st);
  sqlite3_finalize(st);
  return rc == SQLITE_DONE;
}

static bool db_upsert_item_meta_label_plain(const String& item_id, const String& plain_label) {
  if (!db_open()) return false;
  if (g_crypto.K_meta.size() != 32) return false;

  std::vector<uint8_t> aad;
  make_item_label_aad(g_meta.db_uuid, item_id, aad);

  String ct_b64, nonce_b64;
  if (!encrypt_string_meta_b64(aad, plain_label, ct_b64, nonce_b64)) return false;

  return db_upsert_item_meta_label(item_id, ct_b64, nonce_b64);
}

static bool db_migrate_encrypt_names_labels_if_needed(bool wipe_plaintext) {
  if (!db_open()) return false;
  if (g_crypto.K_meta.size() != 32) {
    Serial.println("[MIG] K_meta missing (vault not unlocked?)");
    return false;
  }

  Serial.printf("[MIG] migrate encrypt names/labels wipe_plaintext=%d\n", (int)wipe_plaintext);

  if (!db_begin()) return false;

  // 1) Categories: if category_meta missing/empty, encrypt categories.name into category_meta
  {
    const char* sql =
      "SELECT c.id, c.name, "
      "COALESCE(cm.name_ct_b64,''), COALESCE(cm.name_nonce_b64,'') "
      "FROM categories c "
      "LEFT JOIN category_meta cm ON cm.category_id = c.id;";
    sqlite3_stmt* st = nullptr;
    if (sqlite3_prepare_v2(g_db, sql, -1, &st, nullptr) != SQLITE_OK) { db_rollback(); return false; }

    while (sqlite3_step(st) == SQLITE_ROW) {
      int32_t cid = (int32_t)sqlite3_column_int(st, 0);
      const char* name_plain_c = (const char*)sqlite3_column_text(st, 1);
      const char* ct_c         = (const char*)sqlite3_column_text(st, 2);
      const char* nonce_c      = (const char*)sqlite3_column_text(st, 3);

      String plain = name_plain_c ? String(name_plain_c) : String();
      String ct    = ct_c ? String(ct_c) : String();
      String nonce = nonce_c ? String(nonce_c) : String();

      if (ct.length() && nonce.length()) continue;     // already migrated
      if (!plain.length()) continue;                   // nothing to migrate

      if (!db_upsert_category_meta(cid, plain)) {
        sqlite3_finalize(st);
        db_rollback();
        return false;
      }
    }
    sqlite3_finalize(st);
  }

  // 2) Items: if item_meta missing/empty, encrypt items.label_plain into item_meta
  {
    const char* sql =
      "SELECT i.id, i.label_plain, "
      "COALESCE(im.label_ct_b64,''), COALESCE(im.label_nonce_b64,'') "
      "FROM items i "
      "LEFT JOIN item_meta im ON im.item_id = i.id;";
    sqlite3_stmt* st = nullptr;
    if (sqlite3_prepare_v2(g_db, sql, -1, &st, nullptr) != SQLITE_OK) { db_rollback(); return false; }

    while (sqlite3_step(st) == SQLITE_ROW) {
      const char* id_c         = (const char*)sqlite3_column_text(st, 0);
      const char* label_plain_c= (const char*)sqlite3_column_text(st, 1);
      const char* ct_c         = (const char*)sqlite3_column_text(st, 2);
      const char* nonce_c      = (const char*)sqlite3_column_text(st, 3);

      if (!id_c) continue;
      String item_id = String(id_c);

      String plain = label_plain_c ? String(label_plain_c) : String();
      String ct    = ct_c ? String(ct_c) : String();
      String nonce = nonce_c ? String(nonce_c) : String();

      if (ct.length() && nonce.length()) continue;     // already migrated
      if (!plain.length()) continue;

      if (!db_upsert_item_meta_label_plain(item_id, plain)) {
        sqlite3_finalize(st);
        db_rollback();
        return false;
      }
    }
    sqlite3_finalize(st);
  }

  // 3) Optional: wipe plaintext after successful meta migration
  if (wipe_plaintext) {
    if (!db_exec("UPDATE categories SET name='' WHERE name<>'';")) { db_rollback(); return false; }
    if (!db_exec("UPDATE items SET label_plain='' WHERE label_plain<>'';")) { db_rollback(); return false; }
  }

  if (!db_commit()) { db_rollback(); return false; }

  Serial.println("[MIG] migration OK");
  return true;
}

// ==== Import from /import/data.xlsx ====
// Simple CSV-style parser: Category,Label,Password
static bool parseImportRow(const String& line,String& outCategory,String& outLabel,String& outPassword) {
  int c1 = line.indexOf(',');
  if (c1 < 0) return false;
  int c2 = line.indexOf(',', c1 + 1);

  if (c2 < 0) {
    // Only two columns given: Category,Label
    outCategory = line.substring(0, c1);
    outLabel    = line.substring(c1 + 1);
    outPassword = "";
  } else {
    outCategory = line.substring(0, c1);
    outLabel    = line.substring(c1 + 1, c2);
    outPassword = line.substring(c2 + 1);
  }

  outCategory.trim();
  outLabel.trim();
  outPassword.trim();

  // Strip optional surrounding double quotes
  auto stripQuotes = [](String& s) {
    if (s.length() >= 2 && s[0] == '"' && s[s.length() - 1] == '"') {
      s = s.substring(1, s.length() - 1);
      s.trim();
    }
  };
  stripQuotes(outCategory);
  stripQuotes(outLabel);
  stripQuotes(outPassword);

  return true;
}

static void importFromExcelIfPresent() {
  if (!g_crypto.unlocked) return; // must be unlocked (keys available)

  if (!g_sd.exists(IMPORT_XLSX_PATH)) {
    Serial.println("[IMPORT] No /import/data.xlsx found, skipping import.");
    return;
  }

  Serial.println("[IMPORT] Found /import/data.xlsx, starting import...");
  File f = g_sd.open(IMPORT_XLSX_PATH, FILE_READ);
  if (!f) {
    Serial.println("[IMPORT] Failed to open data.xlsx");
    waitForButtonB("Import", "Open /import/data.xlsx failed", "OK");
    return;
  }

  LoadingScope loading("IMPORT", "Reading data.xlsx...");

  size_t imported      = 0;
  size_t skipped       = 0;
  bool   headerChecked = false;
  size_t lineNo        = 0;

  while (f.available()) {
    String line = f.readStringUntil('\n');
    lineNo++;
    line.trim();
    if (!line.length()) continue;          // skip empty lines
    if (line[0] == '#' || line[0] == ';')  // comment lines
      continue;

    // Handle optional UTF‑8 BOM on first line
    if (lineNo == 1 && line.startsWith("\xEF\xBB\xBF")) {
      line.remove(0, 3);
      line.trim();
      if (!line.length()) continue;
    }

    // Detect and skip header row once
    if (!headerChecked) {
      headerChecked = true;
      String lower = line;
      lower.toLowerCase();
      if (lower.indexOf("category") >= 0 &&
          lower.indexOf("label")    >= 0 &&
          lower.indexOf("password") >= 0) {
        continue; // header line
      }
    }

    String cat, label, pw;
    if (!parseImportRow(line, cat, label, pw)) {
      skipped++;
      continue;
    }

    if (!cat.length() || !label.length()) {
      skipped++;
      continue;
    }

    if (!pw.length()) {
      pw = generatePassword(g_settings);  // auto-generate
    }

    // Find or create category (case‑sensitive)
    Category* targetCat = nullptr;
    for (auto& c : g_vault.categories) {
      if (c.name == cat) { targetCat = &c; break; }
    }
    if (!targetCat) {
      if (g_vault.categories.size() >= MAX_CATEGORIES) {
        Serial.println("[IMPORT] Max categories reached, skipping row");
        skipped++;
        continue;
      }
      int32_t newId = -1;
      if (!db_insert_category(cat, newId)) {
        Serial.println("[IMPORT] db_insert_category failed");
        skipped++;
        continue;
      }
      Category c;
      c.name  = cat;
      c.db_id = newId;
      g_vault.categories.push_back(c);
      targetCat = &g_vault.categories.back();
    }

    // Capacity check per category
    if (targetCat->items.size() >= MAX_PASSWORDS_PER_CATEGORY) {
      Serial.println("[IMPORT] Max passwords per category reached, skipping row");
      skipped++;
      continue;
    }

    // Build PasswordItem with encrypted fields
    PasswordItem it;
    it.id = make_id_16();

    if (!encrypt_label_password(label, pw, it.id,it.label_ct_b64, it.label_nonce_b64,it.pw_ct_b64, it.pw_nonce_b64)) {
      Serial.println("[IMPORT] encrypt_label_password failed");
      skipped++;
      continue;
    }
    it.label_plain = label;

    if (!db_insert_item(targetCat->db_id, it)) {
      Serial.println("[IMPORT] db_insert_item failed");
      skipped++;
      continue;
    }

    targetCat->items.push_back(it);
    imported++;

    if ((imported + skipped) % 10 == 0) {
      char buf[48];
      snprintf(buf, sizeof(buf), "Imported %u, skipped %u",
               (unsigned)imported, (unsigned)skipped);
      updateLoading(buf);
    }
  }
  f.close();

  // Delete the import file as requested
  if (g_sd.remove(IMPORT_XLSX_PATH)) {
    Serial.println("[IMPORT] data.xlsx removed after import");
  } else {
    Serial.println("[IMPORT] Failed to remove data.xlsx");
  }

  // Re-sort for UI; item_names_decrypted will be rebuilt by refreshDecryptedItemNames()
  sortCategoriesByName();
  for (auto& c : g_vault.categories) {
    sortItemsByName(c);
  }

  char msg[64];
  snprintf(msg, sizeof(msg), "Imported %u, skipped %u",
           (unsigned)imported, (unsigned)skipped);
  waitForButtonB("Import done", msg, "OK");
}